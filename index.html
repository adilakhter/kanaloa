<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Kanaloa by iheartradio</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Kanaloa</h1>
        <p class="header">akka actor scala reactive</p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/iheartradio/kanaloa/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/iheartradio/kanaloa/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/iheartradio/kanaloa">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/iheartradio">iheartradio</a></p>


      </header>
      <section>
        <p><a href="https://gitter.im/iheartradio/kanaloa?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://badges.gitter.im/Join%20Chat.svg" alt="Join the chat at https://gitter.im/iheartradio/kanaloa"></a>
<a href="https://travis-ci.org/iheartradio/kanaloa"><img src="https://travis-ci.org/iheartradio/kanaloa.svg" alt="Build Status"></a></p>

<h1>
<a id="kanaloa" class="anchor" href="#kanaloa" aria-hidden="true"><span class="octicon octicon-link"></span></a>Kanaloa</h1>

<h4>
<a id="a-set-of-work-dispatchers-implemented-using-akka-actors" class="anchor" href="#a-set-of-work-dispatchers-implemented-using-akka-actors" aria-hidden="true"><span class="octicon octicon-link"></span></a>A set of work dispatchers implemented using Akka actors</h4>

<p>Note: kanaloa work dispatchers are not Akka <a href="http://doc.akka.io/docs/akka/snapshot/scala/dispatchers.html">MessageDispatcher</a>.</p>

<h3>
<a id="motivation" class="anchor" href="#motivation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Motivation</h3>

<p>Kanaloa work dispatchers sit in front of your service and dispatches received work to them. They make your service more resilient through the following means:</p>

<ol>
<li>
<strong>Auto scaling</strong> - it dynamically figures out the optimal number of concurrent requests your service can handle, and make sure that at any given time your service handles no more than that number of concurrent requests. This simple mechanism was also ported and contributed to Akka's <a href="http://doc.akka.io/docs/akka/2.4.1/scala/routing.html#Optimal_Size_Exploring_Resizer">Optimal Size Exploring Resizer</a> with some limitations. See details of the algorithm below.</li>
<li>
<strong>Back pressure control</strong> - this control is <a href="https://en.wikipedia.org/wiki/Little%27s_law">Little's law</a> inspired. It rejects requests when estimated wait time for which exceeds a certain threshold.</li>
<li>
<strong>Circuit breaker</strong> - when error rate from your service goes above a certain threshold, the kanaloa dispatcher stops all requests for a short period of time to give your service a chance to "cool down".</li>
<li>
<strong>Real-time monitoring</strong> - a built-in statsD reporter allows you to monitor a set of critical metrics (throughput, failure rate, queue length, expected wait time, service process time, number of concurrent requests, etc) in real time. It also provides real-time insights into how kanaloa dispatchers are working. An example on Grafana:
<img src="https://github.com/iheartradio/docker-grafana-graphite/blob/master/dashboard.png" alt="Dashboard">
</li>
</ol>

<p>For the detailed algorithm please see the <a href="#impl">implementation detail</a> below.</p>

<h3>
<a id="get-started" class="anchor" href="#get-started" aria-hidden="true"><span class="octicon octicon-link"></span></a>Get started</h3>

<h4>
<a id="install-dependency" class="anchor" href="#install-dependency" aria-hidden="true"><span class="octicon octicon-link"></span></a>Install dependency</h4>

<pre><code>resolvers += Resolver.jcenterRepo

libraryDependencies +=  "com.iheart" %% "kanaloa" % "0.2.0"
</code></pre>

<h4>
<a id="config" class="anchor" href="#config" aria-hidden="true"><span class="octicon octicon-link"></span></a>Config</h4>

<p>An example of a <code>my-dispatcher</code></p>

<pre><code>kanaloa {
  dispatchers {
    my-service1 {
      workerPool {
       startingPoolSize = 8
      }
      workTimeout = 3s
      circuitBreaker {
        errorRateThreshold = 0.7
      }
    }
  }
}
</code></pre>

<p>For more configuration settings and their documentation please see the <a href="src/main/resources/reference.conf">reference configuration</a></p>

<h4>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Usage</h4>

<p>There are two types kanaloa dispatchers: PushingDispatcher and PullingDispatcher.
<code>PushingDispatcher</code> takes work requests when you send message to it.</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">system</span> <span class="pl-k">=</span> <span class="pl-en">ActorSystem</span>()

<span class="pl-c">// suppose you wrote your service in an actor,</span>
<span class="pl-c">// which takes a SomeWork(someRequest) message and</span>
<span class="pl-c">// replies SuccessResult(someResults) when it succeeds</span>
<span class="pl-k">val</span> <span class="pl-en">serviceActor</span> <span class="pl-k">=</span> system.actorOf(<span class="pl-en">MyServiceActor</span>.props)

<span class="pl-k">val</span> <span class="pl-en">dispatcher</span> <span class="pl-k">=</span>
  system.actorOf(<span class="pl-en">PushingDispatcher</span>.props(
    name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>my-service1<span class="pl-pds">"</span></span>,
    serviceActor
  ) {
    <span class="pl-k">case</span> <span class="pl-en">SuccessResult</span>(r) <span class="pl-k">=&gt;</span> <span class="pl-en">Right</span>(r)  <span class="pl-c">// ResultChecker that tells kanaloa if the request is handled succesffully</span>
    <span class="pl-k">case</span> _ <span class="pl-k">=&gt;</span> <span class="pl-en">Left</span>(<span class="pl-s"><span class="pl-pds">"</span>shit happened<span class="pl-pds">"</span></span>)
  })

dispatcher <span class="pl-k">!</span> <span class="pl-en">SomeWork</span>(<span class="pl-s"><span class="pl-pds">"</span>blahblah<span class="pl-pds">"</span></span>) <span class="pl-c">//dispatcher replies the result (whatever wrapped in the SuccessResult) back.</span>
</pre></div>

<p><code>PullingPatcher</code> pulls work from an iterator, ideal when you have control over the source of the work (e.g. a task iterates through your DB)</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-c">//assume you have the same system and serviceActor as above.</span>

<span class="pl-c">//unrealistic example of an iterator you would pass into a PullingDispatcher</span>
<span class="pl-k">val</span> <span class="pl-en">iterator</span> <span class="pl-k">=</span> <span class="pl-en">List</span>(<span class="pl-en">SomeWork</span>(<span class="pl-s"><span class="pl-pds">"</span>work1<span class="pl-pds">"</span></span>), <span class="pl-en">SomeWork</span>(<span class="pl-s"><span class="pl-pds">"</span>work2<span class="pl-pds">"</span></span>), <span class="pl-en">SomeWork</span>(<span class="pl-s"><span class="pl-pds">"</span>work3<span class="pl-pds">"</span></span>)).iterator

<span class="pl-k">val</span> <span class="pl-en">dispatcher</span> <span class="pl-k">=</span>
  system.actorOf(<span class="pl-en">PullingDispatcher</span>.props(
    name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>my-service2<span class="pl-pds">"</span></span>,
    iterator,
    serviceActor
  ) {
    <span class="pl-k">case</span> <span class="pl-en">SuccessResult</span>(r) <span class="pl-k">=&gt;</span> <span class="pl-en">Right</span>(r)     <span class="pl-c">// this is your ResultChecker which tell kanaloa if the request is handled succesffully</span>
    <span class="pl-k">case</span> _ <span class="pl-k">=&gt;</span> <span class="pl-en">Left</span>(<span class="pl-s"><span class="pl-pds">"</span>shit happened<span class="pl-pds">"</span></span>)
  })

dispatcher <span class="pl-k">!</span> <span class="pl-en">SomeWork</span>(<span class="pl-s"><span class="pl-pds">"</span>blahblah<span class="pl-pds">"</span></span>) <span class="pl-c">//dispatcher replies the result (whatever wrapped in the SuccessResult) back.</span>

</pre></div>

<p>We used an <a href="http://doc.akka.io/api/akka/snapshot/index.html#akka.actor.ActorRef">ActorRef</a> as service here, Kanaloa also supports <a href="http://doc.akka.io/api/akka/snapshot/index.html#akka.actor.Props">Props</a> and <code>T =&gt; Future[R]</code> function as service. You can use any <code>T</code> as service if you implement an implicit <code>T =&gt; Backend</code> where <code>Backend</code> is a simple trait:</p>

<pre><code>trait Backend { def apply(af: ActorRefFactory): ActorRef }
</code></pre>

<h3>
<a id="statsd-monitor" class="anchor" href="#statsd-monitor" aria-hidden="true"><span class="octicon octicon-link"></span></a>StatsD monitor</h3>

<p>Kanaloa has a built-in statsD reporter that allows users to monitor important metrics in real time.</p>

<h4>
<a id="config-statsd" class="anchor" href="#config-statsd" aria-hidden="true"><span class="octicon octicon-link"></span></a>Config StatsD</h4>

<p>Add following to your config</p>

<pre><code>kanaloa {
  metrics {
    statsd {
      host = "localhost" #host of your statsD server
      port = 8125
    }
  }
}
</code></pre>

<p>For more settings please see the <a href="src/main/resources/reference.conf">reference configuration</a></p>

<h4>
<a id="visualize-with-grafana" class="anchor" href="#visualize-with-grafana" aria-hidden="true"><span class="octicon octicon-link"></span></a>Visualize with Grafana</h4>

<p>We provide a <a href="grafana/dashboard.json">grafana dashboard</a> if you are using grafana for statsD visualization.
We also provide a <a href="https://github.com/iheartradio/docker-grafana-graphite">docker image</a> with which you can quickly get up and running a statsD server and visualization web app. Please follow the instructions there.</p>

<h3>
<a id="implementation-detail" class="anchor" href="#implementation-detail" aria-hidden="true"><span class="octicon octicon-link"></span></a><a name="impl"></a>Implementation Detail</h3>

<p>Disclaimer: some of the follow descriptions were adapted from the documentation of Akka's <a href="http://doc.akka.io/docs/akka/2.4.1/scala/routing.html#Optimal_Size_Exploring_Resizer">OptimalSizeExploringResizer</a>, which was also written by the original author of this document.</p>

<p>Behind the scene kanaloa dispatchers creates a set of workers that work with your services. These workers wait for result coming back from the service before they accept more work from the dispatcher. This way it controls the number of concurrent requests dispatchers send to services. It auto-scales the work pool to an optimal size that provides the highest throughput.</p>

<p>This auto-scaling works best when you expect the pool size to performance function to be a convex function, with which you can find a global optimal by walking towards a better size. For example CPU bound service may have an optimal worker pool size tied to the CPU cores available. When your service is IO bound, the optimal size is bound to optimal number of concurrent connections to that IO service - e.g. a 4 node elastic search cluster may handle 4-8 concurrent requests at optimal speed.</p>

<p>The dispatchers keep track of throughput at each pool size and performing the following three resizing operations (one at a time) periodically:</p>

<ol>
<li>Downsize if it hasn't seen all workers ever fully utilized for a period of time.</li>
<li>Explore to a random nearby pool size to try and collect throughput metrics.</li>
<li>Optimize to a nearby pool size with a better (than any other nearby sizes) throughput metrics.</li>
</ol>

<p>When the pool is fully-utilized (i.e. all workers are busy), it randomly choose between exploring and optimizing. When the pool has not been fully-utilized for a period of time, it will downsize the pool to the last seen max utilization multiplied by a configurable ratio.</p>

<p>By constantly exploring and optimizing, the resizer will eventually walk to the optimal size and remain nearby. When the optimal size changes it will start walking towards the new one.</p>

<h3>
<a id="contribute" class="anchor" href="#contribute" aria-hidden="true"><span class="octicon octicon-link"></span></a>Contribute</h3>

<p>Any contribution and feedback is more than welcome.</p>

<h3>
<a id="special-thanks" class="anchor" href="#special-thanks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Special Thanks</h3>

<p>The auto scaling algorithm was first suggested by <a href="https://github.com/richdougherty" class="user-mention">@richdougherty</a>. <a href="https://github.com/ktoso" class="user-mention">@ktoso</a> kindly reviewed this library and provided valuable feedback.</p>
      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		
  </body>
</html>
